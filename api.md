# API 学习

app = createApp(RootComponent)
app.component('name', Component) 挂载应用级组件
app.config 属性对象上配置一些应用级的选项
app.mount(dom|selector) 返回值是根组件实例而非应用实例

应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。

当根组件没有设置 template 选项时，Vue 将自动使用容器的 innerHTML 作为模板。

## 模版语法

1. 文本插值 {{}}

2. 原始 HTML v-html
   不能使用 v-html 来拼接组合模板
3. 属性绑定 v-bind:attribute=expression
   如果绑定的值是 null 或者 undefined，那么该 attribute 将会从渲染的元素上移除。
   布尔型 Attribute 其为其他假值时 attribute 将被忽略,为真或`''`时保留。
   动态绑定多个值 不带参数的 v-bind 绑定 属性及属性值的映射对象

   Vue 所有的数据绑定中都支持完整的 JavaScript 表达式，并以当前组件实例为作用域解析执行。
   在 Vue 模板内，JavaScript 表达式可以被使用在如下场景上：

   - 在文本插值中 (双大括号)
   - 在任何 Vue 指令 (以 v- 开头的特殊 attribute) attribute 的值中

## 指令

指令 attribute 的期望值为一个 JavaScript 表达式 (除了少数几个例外，即 v-for、v-on 和 v-slot)。一个指令的任务是在其表达式的值变化时`响应式地更新 DOM`。

动态参数 :[param] 参数会作为一个 JavaScript 表达式被动态执行，计算得到的值会被用作最终的参数。

动态参数值的限制
动态参数中表达式的值应当是一个字符串，或者是 null。特殊值 null 意为显式移除该绑定。其他非字符串的值会触发警告。

动态参数语法的限制
动态参数表达式因为某些字符的缘故有一些语法限制，比如空格和引号，在 HTML attribute 名称中都是不合法的。
当使用 DOM 内嵌模板 (直接写在 HTML 文件里的模板) 时，我们需要避免在名称中使用大写字母。单文件组件内的模板不受此限制。

修饰符
修饰符是以点开头的特殊后缀，表明指令需要以一些特殊的方式被绑定。

## 计算属性

计算属性允许我们声明性地计算衍生值。
无副作用

## 响应式

reactive()
Vue 能够跟踪对响应式对象属性的访问与更改操作。

`<script setup>`避免在 setup() 函数中手动暴露大量的状态和方法。
`<script setup>` 中的顶层的导入和变量声明可在同一组件的模板中直接使用。

DOM 更新时机
当你更改响应式状态后，DOM 会自动更新。然而，DOM 的更新并不是同步的。相反，Vue 将缓冲它们直到更新周期的 “下个时机” 以确保无论你进行了多少次状态更改，每个组件都只更新一次。

nextTick()

深层响应性

在 Vue 中，状态都是默认深层响应式的。

只有代理对象是响应式的，更改原始对象不会触发更新。
对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身。

响应式对象内的嵌套对象依然是代理。

reactive() API 有两条限制：

- 仅对对象类型有效（对象、数组和 Map、Set 这样的集合类型），而对 string、number 和 boolean 这样的 原始类型 无效。
- 因为 Vue 的响应式系统是通过属性访问进行追踪的，因此必须始终保持对该响应式对象的相同引用。因此，不可以随意地“替换”一个响应式对象，不可将响应式对象的属性赋值或解构至本地变量时，或是将该属性传入一个函数。

ref() 方法来允许创建可以使用任何值类型的响应式 ref 对象
ref 的 .value 属性也是响应式的。同时，当值为对象类型时，会用 reactive() 自动转换它的 .value。

一个包含对象类型值的 ref 可以响应式地替换整个对象。
ref 被传递给函数或是从一般对象上被解构时，不会丢失响应性。

ref() 让我们能创造一种对任意值的 “引用”，并能够在不丢失响应性的前提下传递这些引用。

当 ref 在模板中作为顶层属性被访问时，它们会被自动“解包”，所以不需要使用 .value。
仅当 ref 是模板渲染上下文的顶层属性时才适用自动“解包”。

ref 在响应式对象中的解包
当一个 ref 被嵌套在一个响应式对象中，作为属性被访问或更改时，它会自动解包，因此会表现得和一般的属性一样。
如果将一个新的 ref 赋值给一个关联了已有 ref 的属性，那么它会替换掉旧的 ref。

只有当嵌套在一个深层响应式对象内时，才会发生 ref 解包。当其作为浅层响应式对象的属性被访问时不会解包。

数组和集合类型的 ref 解包
跟响应式对象不同，当 ref 作为响应式数组或像 Map 这种原生集合类型的元素被访问时，不会进行解包。

## 条件渲染

- v-if
- v-else-if
- v-else
- v-show

当 v-if 和 v-for 同时存在于一个元素上的时候，v-if 会首先被执行。

v-if 与 v-show 的区别

- v-if 能确保条件区块内的事件监听器和子组件都会被销毁与重建。并且渲染是惰性的。
- v-show 不支持在 `<template>` 元素上使用，也不能和 v-else 搭配使用。
- v-show 无论初始条件如何，始终会被渲染，只有 CSS display 属性会被切换。
- v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。

## 列表渲染

v-for 可以遍历数组和对象，甚至范围； 支持 in 或 of 分隔；可以用在 `<template>` 标签上使用 v-for 来渲染一个包含多个元素的块。

通过 key 管理状态
Vue 默认按照“就地更新”的策略来更新通过 v-for 渲染的元素列表。当数据项的顺序改变时，Vue 不会随之移动 DOM 元素的顺序，而是就地更新每个元素，确保它们在原本指定的索引位置上渲染。

默认模式是高效的，但只适用于列表渲染输出的结果不依赖子组件状态或者临时 DOM 状态 (例如表单输入值) 的情况。

在任何可行的时候为 v-for 提供一个 key attribute，除非所迭代的 DOM 内容非常简单 (例如：不包含组件或有状态的 DOM 元素)，或者你想有意采用默认行为来提高性能。

key 绑定的值期望是一个基础类型的值，例如字符串或 number 类型。不要用对象作为 v-for 的 key。

数组变化侦测

变更方法
Vue 能够侦听响应式数组的变更方法，并在它们被调用时触发相关的更新。

- push()
- pop()
- shift()
- unshift()
- splice()
- sort()
- reverse()

替换数组
当遇到的是非变更方法时，我们需要将旧的数组替换为新的。

## 事件处理

事件处理器的值

- 内联
- 方法

事件修饰符

- prevent 阻止默认行为
- stop 阻止继续冒泡
- capture 在被内部元素处理前，先被外部处理
- self 仅当 event.target 是元素本身时才会触发事件处理器
- once 最多被触发一次
- passive 一般用于触摸事件的监听器，可以用来改善移动端设备的滚屏性能 .passive 已经向浏览器表明了你不想阻止事件的默认行为

按键修饰符

- enter
- page-dwon
- delete
- esc
- space
- left
- right
- up
- down

系统按键修饰符

- ctrl
- shift
- alt
- meta
- exact 修饰符允许控制触发一个事件所需的确定组合的系统按键修饰符。

鼠标按键修饰符

- left
- right
- middle

## 表单输入绑定

v-model 根据所使用的元素自动使用对应的 DOM 属性和事件组合

- 文本类型的 `<input>` 和 `<textarea>` 元素会绑定 `value` property 并侦听 `input` 事件；
- `<input type="checkbox">` 和 `<input type="radio">` 会绑定 `checked` property 并侦听 `change` 事件；
- `<select>` 会绑定 `value` property 并侦听 `change` 事件。
- v-model 会忽略任何表单元素上初始的 value、checked 或 selected attribute

在 `<textarea>` 中是不支持插值表达式的

true-value 和 false-value 是 Vue 特有的 attributes，仅支持和 v-model 配套使用。

修饰符

- lazy 默认情况下，v-model 会在每次 input 事件后更新数据。可以添加 lazy 修饰符来改为在每次 change 事件后更新数据。
- number 通过 parseFloat 自动转换为数字,如果失败返回原始值。number 修饰符会在输入框有 type="number" 时自动启用。
- trim 去除两端空格

自定义组件上也支持 v-model。

## 生命周期

## 侦听器

有副作用
watch(attribute, callback)
侦听数据源：

- ref (包括计算属性)
- 响应式对象
- getter 函数
- 多个数据源组成的数组

不能直接侦听响应式对象的属性值

深层侦听器
直接给 watch() 传入一个响应式对象，会隐式地创建一个深层侦听器。

显式地加上 deep 选项，强制转成深层侦听器

watch 默认是懒执行的：仅当数据源变化时，才会执行回调。当希望在创建侦听器时，立即执行一遍回调时，传入 immediate: true 选项来强制侦听器的回调立即执行。

watchEffect() 自动跟踪回调的响应式依赖，消除手动维护依赖列表的负担。回调会立即执行，不需要指定 immediate: true。

watch vs. watchEffect 追踪响应式依赖的方式

- watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。watch 会避免在发生副作用时追踪依赖，能更加精确地控制回调函数的触发时机。

- watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。这更方便，而且代码往往更简洁，但有时其响应性依赖关系会不那么明确。
- 需要侦听一个嵌套数据结构中的几个属性，watchEffect() 可能会比深度侦听器更有效，因为它将只跟踪回调中被使用到的属性，而不是递归地跟踪所有的属性。
- watchEffect 仅会在其`同步执行期间`，才追踪依赖。在使用异步回调时，只有在第一个 await 正常工作前访问到的属性才会被追踪。

回调的触发时机
当你更改了响应式状态，它可能会同时触发 Vue 组件更新和侦听器回调。

默认情况下，用户创建的侦听器回调，都会在 Vue 组件更新之前被调用。因此在侦听器回调中访问的 DOM 将是被 Vue 更新之前的状态。

如果想在侦听器回调中能访问被 Vue 更新之后的 DOM，需要指明 flush: 'post' 选项。

watchPostEffect() 后置刷新

停止侦听器

在 setup() 或 `<script setup>` 中用同步语句创建的侦听器，会自动绑定到宿主组件实例上，并且会在宿主组件卸载时自动停止。
侦听器必须用同步语句创建。如果用异步回调创建一个侦听器，那么它不会绑定到当前组件上，必须手动停止它，以防内存泄漏。
要手动停止一个侦听器，请调用 watch 或 watchEffect 返回的函数。

## 模版引用

ref 允许我们在一个特定的 DOM 元素或子组件实例被挂载后，获得对它的直接引用。
只可以在组件挂载后才能访问模板引用。
当在 v-for 中使用模板引用时，对应的 ref 中包含的值是一个数组，它将在元素被挂载后包含对应整个列表的所有元素。

函数模板引用(回调 Ref)
会在每次组件更新时都被调用。该函数会收到元素引用作为其第一个参数。
需要使用动态的 :ref 绑定才能够传入一个函数。当绑定的元素被卸载时，函数也会被调用一次，此时的 el 参数会是 null。

有一个例外的情况，使用了 `<script setup>` 的组件是默认私有的：一个父组件无法访问到一个使用了 `<script setup>` 的子组件中的任何东西，除非子组件在其中通过 defineExpose 宏显式暴露。

## 组件

传递 props
defindProps()
defineProps 是一个仅 `<script setup>` 中可用的编译宏命令，并不需要显式地导入。声明的 props 会自动暴露给模板。defineProps 会返回一个对象，其中包含了可以传递给组件的所有 props。

defineEmits()
子组件可以通过调用内置的 $emit 方法，通过传入事件名称来抛出一个事件。

通过插槽来分配内容

动态组件
通过 Vue 的 `<component> `元素和特殊的 `is` attribute 实现。
被切换掉的组件会被卸载。可以通过 `<KeepAlive>` 组件强制被切换掉的组件仍然保持“存活”的状态。

DOM 模板解析的所有注意事项

- 大小写区分
- 闭合标签
- 元素位置限制

## 组件注册

全局组册
使用 component()方法将组件注册在应用上，应用的所有组件上不用再注册就可以使用。全局注册会使 TreeShaking 优化失效，组件间的依赖关系不明显。

局部注册
使用`<script setup>`的 SFC,导入之后就可直接使用，无需手动注册；不使用的还需要使用 components 属性进行注册。相对全局注册，组件间的依赖关系明确，支持 Tree shaking 优化。
